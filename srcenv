#!/bin/sh
#
# srcenv.tests - A cross-shell tool for sourcing POSIX compliant .env scripts
#
# shellcheck disable=SC2016
# shellcheck disable=SC2317

version() { echo "srcenv 1.3.10"; }

# region Help / Usage

header() {
    NORMAL=$(tput sgr0 2> /dev/null || printf '\033[0m')
    BOLD=$(tput bold 2> /dev/null || printf '\033[1m')
    DIM=$(tput dim 2> /dev/null || printf '\033[2m')
    ITALIC=$(tput sitm 2> /dev/null || printf '\033[3m')
    UNDERLINE=$(tput smul 2> /dev/null || printf '\033[4m')
    YELLOW=$(tput setaf 3 2> /dev/null || printf '\033[33m')

    warn=; command -v "$jq" > /dev/null || \
    warn=$(printf "%$((40 + (${#NORMAL} * 2 + ${#BOLD} * 2 + ${#YELLOW})))s" \
                  "${BOLD}${YELLOW}warning: ${NORMAL}${BOLD}$jq${NORMAL} not found")

    echo >&2 "\
srcenv is a cross-shell tool for sourcing POSIX compliant .env scripts.

${BOLD}${UNDERLINE}Usage${NORMAL}: ${BOLD}srcenv${NORMAL} [${ITALIC}options${NORMAL}] [${ITALIC}files${NORMAL}]         $warn
              [-h|--help|-v|--version]

srcenv takes a snapshot of the POSIX shell environment, sources the .env scripts
and prints a script exporting the environment variables that have changed since
the snapshot, for one of the following shells:

    ${DIM}bash, csh/tcsh, dash, elvish, fish, murex, nushell, powershell, zsh${NORMAL}
"
}

help() {
    NORMAL=$(tput sgr0 2> /dev/null || printf '\033[0m')
    BOLD=$(tput bold 2> /dev/null || printf '\033[1m')
    ITALIC=$(tput sitm 2> /dev/null || printf '\033[3m')

    echo >&2 "\
For listing the command options, use '${0##*/} ${BOLD}--help${NORMAL}'.

For more advanced usage see the srcenv(1) manpage ${ITALIC}('man srcenv')${NORMAL} and/or
https://github.com/ins0mniaque/srcenv/."
}

usage() {
    NORMAL=$(tput sgr0 2> /dev/null || printf '\033[0m')
    BOLD=$(tput bold 2> /dev/null || printf '\033[1m')
    ITALIC=$(tput sitm 2> /dev/null || printf '\033[3m')
    UNDERLINE=$(tput smul 2> /dev/null || printf '\033[4m')

    echo >&2 "\
${BOLD}${UNDERLINE}Options${NORMAL}:
  ${BOLD}--ash                       ${NORMAL}Format the output as an Ash script
  ${BOLD}--bash                      ${NORMAL}Format the output as a Bash script
  ${BOLD}--bat, --cmd                ${NORMAL}Format the output as a Windows batch script
  ${BOLD}--csh, --tcsh               ${NORMAL}Format the output as a Csh/Tcsh script
  ${BOLD}--dash                      ${NORMAL}Format the output as a Dash script
  ${BOLD}--elvish                    ${NORMAL}Format the output as an Elvish script
  ${BOLD}--env                       ${NORMAL}Format the output as a .env file
  ${BOLD}--fish                      ${NORMAL}Format the output as a Fish script
  ${BOLD}--json                      ${NORMAL}Format the output as JSON
  ${BOLD}--ksh, --pdksh, --mksh      ${NORMAL}Format the output as a Ksh script
  ${BOLD}--launchctl                 ${NORMAL}Format the output as a launchctl calls ${ITALIC}(macOS)${NORMAL}
  ${BOLD}--murex                     ${NORMAL}Format the output as a Murex script
  ${BOLD}--nu, --nushell             ${NORMAL}Format the output as a Nushell script
  ${BOLD}--posix, --sh               ${NORMAL}Format the output as a POSIX shell script
  ${BOLD}--pwsh, --powershell        ${NORMAL}Format the output as a PowerShell script
  ${BOLD}--zsh                       ${NORMAL}Format the output as a Zsh script
  ${BOLD}-f FORMAT, --format FORMAT,
  ${BOLD}-f=FORMAT, --format=FORMAT  ${NORMAL}Format the output as anything ${ITALIC}(jq interpolated string)${NORMAL}

  ${BOLD}-                           ${NORMAL}Source from STDIN
  ${BOLD}-a ARG, --arg ARG,
  ${BOLD}-a=ARG, --arg=ARG           ${NORMAL}Source from string value of ARG
  ${BOLD}-b, --backup                ${NORMAL}Backup changes in SRCENV_UNDO for undo
  ${BOLD}-u, --undo                  ${NORMAL}Undo backed up changes from SRCENV_UNDO
  ${BOLD}-e, --export                ${NORMAL}Export all variables ${ITALIC}(Default for .env/.envrc files)${NORMAL}
  ${BOLD}-l, --local                 ${NORMAL}Do not export all variables
  ${BOLD}-s, --sort                  ${NORMAL}Sort the environment variables alphabetically ${ITALIC}(Default)${NORMAL}
  ${BOLD}-U, --unsorted              ${NORMAL}Keep the environment variables unsorted
  ${BOLD}-h, --help                  ${NORMAL}Display help and exit
  ${BOLD}-v, --version               ${NORMAL}Display the version number and exit

For more advanced usage see the srcenv(1) manpage ${ITALIC}('man srcenv')${NORMAL} and/or
https://github.com/ins0mniaque/srcenv/."
}

nojq() {
    NORMAL=$(tput sgr0 2> /dev/null || printf '\033[0m')
    BOLD=$(tput bold 2> /dev/null || printf '\033[1m')
    RED=$(tput setaf 1 2> /dev/null || printf '\033[31m')
    GREEN=$(tput setaf 2 2> /dev/null || printf '\033[32m')
    YELLOW=$(tput setaf 3 2> /dev/null || printf '\033[33m')

    [ "$jq" != jq ] && \
    echo >&2 "${BOLD}${YELLOW}warn: ${NORMAL} ${YELLOW}jq${NORMAL} is set to ${GREEN}$jq${NORMAL}; unset ${YELLOW}SRCENV_JQ${NORMAL} to revert to ${GREEN}jq${NORMAL}"
    echo >&2 "${BOLD}${RED}error:${NORMAL} ${YELLOW}jq${NORMAL} not found; see https://jqlang.github.io/jq/download/ for installation options"
}

noformat() {
    NORMAL=$(tput sgr0 2> /dev/null || printf '\033[0m')
    BOLD=$(tput bold 2> /dev/null || printf '\033[1m')
    YELLOW=$(tput setaf 3 2> /dev/null || printf '\033[33m')

    echo >&2 "${BOLD}${YELLOW}warn:${NORMAL} Unknown shell ${YELLOW}$pcmd${NORMAL}; defaulting to POSIX format"
}

valid() {
    case $2 in
        -*|'') invalid "$1" "option requires an argument -- -"; exit 1 ;;
        *)     printf  "%s" "$2" ;;
    esac
}

invalid() {
    NORMAL=$(tput sgr0 2> /dev/null || printf '\033[0m')
    BOLD=$(tput bold 2> /dev/null || printf '\033[1m')
    ITALIC=$(tput sitm 2> /dev/null || printf '\033[3m')
    UNDERLINE=$(tput smul 2> /dev/null || printf '\033[4m')
    RED=$(tput setaf 1 2> /dev/null || printf '\033[31m')
    YELLOW=$(tput setaf 3 2> /dev/null || printf '\033[33m')

    LF='
'
    error="${2#getopt: }"
    error="${error%%"${LF}"*}"
    case "$error" in
        *' -- '*) option="${error#* -- }"
                  [ "$option" = '-' ] && option="${1#-}"
                  option="${option#-}"
                  error="${error% -- *}"
                  error="$error -- ${YELLOW}$option${NORMAL}" ;;
        *'`'*\'*) option="${error#*\`}";
                  option="${option%\'*}";
                  error="${error%%\`*}'${YELLOW}$option${NORMAL}'${error##*\'}" ;;
        *\'*\'*)  option="${error#*\'}";
                  option="${option%\'*}";
                  error="${error%%\'*}'${YELLOW}$option${NORMAL}'${error##*\'}" ;;
    esac

    echo >&2 "\
${BOLD}${RED}error:${NORMAL} $error

${BOLD}${UNDERLINE}Usage${NORMAL}: ${BOLD}srcenv${NORMAL} [${ITALIC}options${NORMAL}] [${ITALIC}files${NORMAL}]
              [-h|--help|-v|--version]

For more information, try '${0##*/} ${BOLD}--help${NORMAL}'."
}

err() {
    if [ "$2" = "0" ]; then
        printf >&2 '%s\n' "$1"; return
    fi

    NORMAL=$(tput sgr0 2> /dev/null || printf '\033[0m')
    BOLD=$(tput bold 2> /dev/null || printf '\033[1m')
    RED=$(tput setaf 1 2> /dev/null || printf '\033[31m')
    YELLOW=$(tput setaf 3 2> /dev/null || printf '\033[33m')

    escape=$(printf '\033')
    case $1 in
        '')                echo   >&2 '' ;;
        "$escape"*)        printf >&2 '%s\n' "$1" ;;
        $jq:\ *--argjson*) echo   >&2 "${BOLD}${RED}error:${NORMAL} ${YELLOW}SRCENV_UNDO${NORMAL} environment variable contains invalid JSON: ${RED}$SRCENV_UNDO${NORMAL}" ;;
        $jq:\ *)           LF='
'
                           error=${1#"$jq": }
                           error=${error#error: }
                           error=${error%%, line 1:"${LF}"*}
                           echo   >&2 "${BOLD}${RED}error:${NORMAL} ${BOLD}Invalid format:${NORMAL} $error" ;;
        *)                 printf '%s\n' "$1" | while IFS= read -r line; do
                               line=${line#"$0": }
                               line=${line#line [0-9]*: }

                               echo >&2 "${BOLD}${RED}error:${NORMAL} $line"
                           done ;;
    esac
}

# endregion Help / Usage

init() {
    prefix=
    suffix=
    format=
    export=
    backup=
    undo=

    diff='reduce (env|del(.SHLVL, ._, ._AST_FEATURES)|keys_unsorted[]) as $k ({}; if env[$k] != $snapshot[$k] then .[$k]=env[$k] else . end)'
    ffid='reduce (env|del(.SHLVL, ._, ._AST_FEATURES)|keys_unsorted[]) as $k ({}; if env[$k] != $snapshot[$k] then .[$k]=$snapshot[$k] else . end)'
    keys='keys[] as $k'
    sort='to_entries | sort_by(.key) | from_entries'
}

fmt() { format='if .[$k] != null then "'$1'" else "'$2'" end'; }

setbackup() {
    if [ -z "$SRCENV_UNDO" ]; then
        backup='| ('$ffid') as $ffid | if $ffid != {} then . += { SRCENV_UNDO: ($ffid | . += { SRCENV_UNDO: null } | '$sort' | tostring) } else . end'
    else
        backup='| . += { SRCENV_UNDO: ('$ffid' | . += { SRCENV_UNDO: null } | '$sort' | tostring) }'
    fi
}

autodetect() {
    pcmd="$(ps -o comm= -p "$1")"
    pcmd="${pcmd##*/}"

    case "$pcmd" in
        -ash|ash)       auto=--ash    ;;
        -bash|bash)     auto=--bash   ;;
        -csh|csh)       auto=--csh    ;;
        -tcsh|tcsh)     auto=--tcsh   ;;
        -dash|dash)     auto=--dash   ;;
        -ksh|ksh)       auto=--ksh    ;;
        -pdksh|pdksh)   auto=--pdksh  ;;
        -mksh|mksh)     auto=--mksh   ;;
        -murex|murex)   auto=--murex  ;;
        -sh|sh)         auto=--sh     ;;
        -zsh|zsh)       auto=--zsh    ;;
        -elvish|elvish) auto=--elvish ;;
        -fish|fish)     auto=--fish   ;;
        -nu|nu)         auto=--nu     ;;
        -pwsh|pwsh|\
        -powershell|\
        powershell)     auto=--pwsh   ;;
        0|'')           auto=         ;;
        *)              autodetect "$(ps -o ppid= -p "$1")" ;;
    esac
}

run() {
    if ! command -v "$jq" > /dev/null; then
        nojq; exit 1
    fi

    snapshot=$("$jq" -n env) || exit 1

    while [ $# -gt 0 ]; do
        case $1 in
            --ash|\
            --bash|\
            --dash|\
            --ksh|--pdksh|--mksh|\
            --posix|--sh|\
            --zsh)               fmt 'export \($k)=\(.[$k]|@sh)'       'unset \($k)';    shift ;;
            --csh|--tcsh)        fmt 'setenv \($k) \(.[$k]|@sh|gsub("\\n"; "\\\n"))' \
                                     'unsetenv \($k)';                                   shift ;;
            --elvish)            fmt 'set-env \($k) \(.[$k]|@sh|gsub("'"'\\\\\\\\''"'"; "'\'\''"))' \
                                     'unset-env \($k)';                                  shift ;;
            --fish)              fmt 'set -gx \($k) \(.[$k]|@sh)'      'set -e \($k)';   shift ;;
            --murex)             fmt 'out \(.[$k]|@sh) -> export \($k)' '!export \($k)'; shift ;;
            --nu|--nushell)      fmt '$env.\($k) = r#'"'"'\(.[$k])'"'"'#' \
                                     '$env.\($k) = null';                                shift ;;
            --pwsh|--powershell) fmt '$Env:\($k) = \(.[$k]|@sh|gsub("'"'\\\\\\\\''"'"; "'\'\''"))' \
                                     '$Env:\($k) = $null';                               shift ;;
            --env)               fmt '\($k)=\(.[$k]|@sh)'              '\($k)=';         shift ;;
            --json)              format=.;                                               shift ;;
            --bat|--cmd)         fmt 'set \"\($k)=\(.[$k] | gsub("\n"; "%LF%") | gsub("\""; "^\""))\"' \
                                     'set \($k)=';
                                 prefix='"set LFM=^\n\n\nset LF=^^^%LFM%%LFM%^%LFM%%LFM%\n" + ([';
                                 suffix='] | join("\n")) + "\nset LFM=\nset LF="'; shift ;;
            --launchctl)         fmt 'launchctl setenv \($k) \(.[$k]|@sh)' \
                                     'launchctl unsetenv \($k)'; shift ;;
            -f|--format)         format="$(valid "$@")";           fmt "${format%\?\?*}" "${format#*\?\?}"; shift; [ $# -gt 0 ] && shift ;;
            -f=*|--format=*)     format="$(valid "$1" "${1#*=}")"; fmt "${format%\?\?*}" "${format#*\?\?}"; shift ;;

            -b|--backup)   backup=1;             shift ;;
            -u|--undo)     undo='$undo | . += '; shift ;;
            -e|--export)   export=--export;      shift ;;
            -l|--local)    export=0;             shift ;;
            -s|--sort)     keys='keys[] as $k';
                           sort='to_entries | sort_by(.key) | from_entries'; shift ;;
            -U|--unsorted) keys='keys_unsorted[] as $k'; sort='.';           shift ;;
            -\?|-h|--help) header; usage; exit 0 ;;
            -v|--version)  version;       exit 0 ;;

            -a|--arg)      src var "$(valid "$@")"           "$export"; shift; [ $# -gt 0 ] && shift ;;
            -a=*|--arg=*)  src var "$(valid "$1" "${1#*=}")" "$export"; shift ;;
            -)             src var "$(cat)"                  "$export"; shift ;;
            -*)            # shellcheck disable=SC2086
                           opts=$(getopt "a:bef:hlsuUv" "$1" 2>&1) &&   shift && \
                           set -- ${opts% --} "$@"                 &&   continue
                           invalid "$1" "$opts";                        exit 2 ;;
            *.env|*.envrc) src file "$1" "${export:---export}";         shift ;;
            *)             src file "$1" "$export";                     shift ;;
        esac
    done

    [ -n "$backup"  ] && setbackup
    [ -z "$format"  ] && noformat && fmt 'export \($k)=\(.[$k]|@sh)' 'unset \($k)'
    [ "$format" = . ] && keys="$sort"

    "$jq" --argjson snapshot "$snapshot" \
       ${undo:+--argjson} ${undo:+undo} ${undo:+"${SRCENV_UNDO:-{}}"} \
       -rn "$prefix $undo $diff $backup | $keys | $format $suffix"
}

src() {
    [ "$3" = --export ] && set -a

    if [ "$1" = var ]; then
        eval "$2" 1>&2 || exit 1
    elif [ -f "$2" ]; then
        # shellcheck disable=SC1090
        case "$2" in
            .*|/*) .   "$2" 1>&2 || exit 1 ;;
            *)     . "./$2" 1>&2 || exit 1 ;;
        esac
    else
        echo >&2 "$2: No such file or directory"
        exit 1
    fi

    [ "$3" = --export ] && set +a
}

jq="${SRCENV_JQ:-jq}"

if [ $# = 0 ]; then
    header; help; exit 0
fi

DLM="$(printf '\032')"
LF='
'

capture() {
    stdout="$( (printf "${DLM}%s${DLM}" "$(trap 'printf "${DLM}%d" "$?"' EXIT; "$@")" 1>&2) 2>&1 )"
    exitcode="${stdout%"${DLM}"}"
    exitcode="${exitcode##*"${DLM}"}"
    stderr="${stdout%%"${DLM}"*}"
    stderr="${stderr%"${LF}"}"
    stdout="${stdout#*"${DLM}"}"
    stdout="${stdout%"${DLM}"*"${DLM}"}"
    stdout="${stdout%"${LF}"}"

    return "$exitcode"
}

init
autodetect "$PPID"
capture run ${auto:+"$auto"} "$@"

[ -n "$stderr" ] && err "$stderr" "$exitcode"
[ -n "$stdout" ] && printf '%s\n' "$stdout"

exit "$exitcode"
