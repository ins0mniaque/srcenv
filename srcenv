#!/bin/sh
#
# srcenv - A cross-shell tool for sourcing POSIX compliant .env scripts
#
# shellcheck disable=SC2016
# shellcheck disable=SC2317

version() {
    if [ -z "$cmd" ]; then
        echo 'srcenv 1.5.12'
    else
        echo >&2 'srcenv 1.5.12'
    fi
}

# region Help / Usage

header() { echo >&2 'srcenv is a cross-shell tool for sourcing POSIX compliant .env scripts.'; }

desc() {
    echo >&2 "\
srcenv takes a snapshot of the POSIX shell environment, sources the .env scripts
and prints a shell specific script exporting the environment variables that have
changed since the snapshot.
"
}

help() {
    colors NORMAL BOLD

    echo >&2 "For listing the command options, use '${cmd:-${0##*/}} ${BOLD}--help${NORMAL}'."
}

man() {
    colors NORMAL ITALIC

    echo >&2 "
For more advanced usage see the srcenv(1) manpage ${ITALIC}('man srcenv')${NORMAL} and/or
https://github.com/ins0mniaque/srcenv."
}

usage() {
    colors NORMAL BOLD ITALIC UNDERLINE YELLOW

    if [ -z "$cmd" ]; then
        warn=; command -v "$jq" > /dev/null || \
        warn=$(printf "%$((32 + (${#NORMAL} * 2 + ${#BOLD} * 2 + ${#YELLOW})))s" \
                      "${BOLD}${YELLOW}warning: ${NORMAL}${BOLD}$jq${NORMAL} not found")

        echo >&2 "
${BOLD}${UNDERLINE}Usage${NORMAL}: ${BOLD}srcenv${NORMAL} <${ITALIC}shell${NORMAL}> [${ITALIC}options${NORMAL}] [${ITALIC}files${NORMAL}]         $warn
              init|rc <${ITALIC}shell${NORMAL}> [--cmd ${ITALIC}name${NORMAL}] [-- ${ITALIC}options${NORMAL}]
              [-h|--help|--version]
"
    else
        warn=; command -v "$jq" > /dev/null || \
        warn=$(printf "%$((46 - ${#cmd} + (${#NORMAL} * 2 + ${#BOLD} * 2 + ${#YELLOW})))s" \
                      "${BOLD}${YELLOW}warning: ${NORMAL}${BOLD}$jq${NORMAL} not found")
        help=$(printf "%$((29 + ${#cmd}))s" \
                      "[-h|--help|--version]")

        echo >&2 "
${BOLD}${UNDERLINE}Usage${NORMAL}: ${BOLD}$cmd${NORMAL} [${ITALIC}options${NORMAL}] [${ITALIC}files${NORMAL}]         $warn
$help
"
    fi
}

options() {
    colors NORMAL BOLD ITALIC UNDERLINE

    if [ -z "$cmd" ]; then
        echo >&2 "\
${BOLD}${UNDERLINE}Commands${NORMAL}:
  ${BOLD}init              ${NORMAL}Generate the initialization script
  ${BOLD}rc                ${NORMAL}Generate the command to install the initialization script

${BOLD}${UNDERLINE}Shells${NORMAL}:
  ${BOLD}ash, dash         ${NORMAL}Format the output as an Ash/Dash script
  ${BOLD}bash              ${NORMAL}Format the output as a Bash script
  ${BOLD}cmd, command      ${NORMAL}Format the output as a Windows Command shell script
  ${BOLD}csh, tcsh         ${NORMAL}Format the output as a Csh/Tcsh script
  ${BOLD}elvish            ${NORMAL}Format the output as an Elvish script
  ${BOLD}env               ${NORMAL}Format the output as a .env file
  ${BOLD}fish              ${NORMAL}Format the output as a Fish script
  ${BOLD}json              ${NORMAL}Format the output as JSON
  ${BOLD}ksh, pdksh, mksh  ${NORMAL}Format the output as a Ksh script
  ${BOLD}launchctl         ${NORMAL}Format the output as a launchctl calls ${ITALIC}(macOS)${NORMAL}
  ${BOLD}murex             ${NORMAL}Format the output as a Murex script
  ${BOLD}nu, nushell       ${NORMAL}Format the output as a Nushell script
  ${BOLD}posix, sh         ${NORMAL}Format the output as a POSIX shell script
  ${BOLD}pwsh, powershell  ${NORMAL}Format the output as a PowerShell script
  ${BOLD}zsh               ${NORMAL}Format the output as a Zsh script
"
    fi

    echo >&2 "\
${BOLD}${UNDERLINE}Options${NORMAL}:
  ${BOLD}-x VAR, --exclude VAR,
  ${BOLD}-x=VAR, --exclude=VAR       ${NORMAL}Exclude VAR from exported variables ${ITALIC}(can be used multiple times)${NORMAL}
  ${BOLD}-f FORMAT, --format FORMAT,
  ${BOLD}-f=FORMAT, --format=FORMAT  ${NORMAL}Format the output as anything ${ITALIC}(shell or jq interpolated string)${NORMAL}
                              ${ITALIC}${DIM}e.g. 'json' or '\(\$k)=\(.[\$k]|@sh)??\(\$k)='${NORMAL}
  ${BOLD}-i INPUT, --input INPUT,
  ${BOLD}-i=INPUT, --input=INPUT     ${NORMAL}Source from string value of INPUT
  ${BOLD}-                           ${NORMAL}Source from STDIN
  ${BOLD}-b, --backup                ${NORMAL}Backup changes to SRCENV_RESTORE for restore
  ${BOLD}-r, --restore               ${NORMAL}Restore backed up changes from SRCENV_RESTORE
  ${BOLD}-c, --clear                 ${NORMAL}Clear backed up changes from SRCENV_RESTORE
  ${BOLD}-n                          ${NORMAL}Do not backup changes and do not restore backed up changes
  ${BOLD}--no-backup                 ${NORMAL}Do not backup changes to SRCENV_RESTORE for restore
  ${BOLD}--no-restore                ${NORMAL}Do not restore backed up changes from SRCENV_RESTORE
  ${BOLD}-m, --modify                ${NORMAL}Allow modifying existing environment variables ${ITALIC}(Default)${NORMAL}
  ${BOLD}-w, --write-protect         ${NORMAL}Do not allow modifying existing environment variables
  ${BOLD}-j, --json                  ${NORMAL}Treat input as JSON${NORMAL}
  ${BOLD}-p, --posix                 ${NORMAL}Treat input as POSIX ${ITALIC}(Default)${NORMAL}
  ${BOLD}-e, --export                ${NORMAL}Export all variables ${ITALIC}(Default for .env files)${NORMAL}
  ${BOLD}-l, --local                 ${NORMAL}Do not export all variables
  ${BOLD}-s, --sort                  ${NORMAL}Sort the environment variables alphabetically ${ITALIC}(Default)${NORMAL}
  ${BOLD}-u, --unsorted              ${NORMAL}Keep the environment variables unsorted
  ${BOLD}-q, --quiet                 ${NORMAL}Do not display changed environment variables
  ${BOLD}-v, --verbose               ${NORMAL}Display changed environment variables
  ${BOLD}-h, --help                  ${NORMAL}Display help and exit
  ${BOLD}--version                   ${NORMAL}Display the version number and exit
"
}

noinput() {
    colors NORMAL BOLD RED

    echo >&2 "${BOLD}${RED}error:${NORMAL} no input files or arguments"
}

nojq() {
    colors NORMAL BOLD RED GREEN YELLOW

    [ "$jq" != jq ] && \
    echo >&2 "${BOLD}${YELLOW}warn: ${NORMAL} ${YELLOW}jq${NORMAL} is set to ${GREEN}$jq${NORMAL}; unset ${YELLOW}SRCENV_JQ${NORMAL} to revert to ${GREEN}jq${NORMAL}"
    echo >&2 "${BOLD}${RED}error:${NORMAL} ${YELLOW}jq${NORMAL} not found; see https://jqlang.github.io/jq/download for installation options"
}

noformat() {
    colors NORMAL BOLD RED

    echo >&2 "${BOLD}${RED}error:${NORMAL} no shell or format specified"
}

noshell() {
    colors NORMAL BOLD RED YELLOW

    [ -z "$1" ] && \
    echo >&2 "${BOLD}${RED}error:${NORMAL} no shell specified" || \
    echo >&2 "${BOLD}${RED}error:${NORMAL} ${YELLOW}$1${NORMAL} is not a supported shell"
}

nosupport() {
    colors NORMAL BOLD RED YELLOW

    echo >&2 "${BOLD}${RED}error:${NORMAL} ${BOLD}$1${NORMAL} not supported for shell ${YELLOW}$shell${NORMAL}"
}

invalid() {
    colors NORMAL BOLD ITALIC UNDERLINE RED YELLOW

    LF='
'
    error=${2#getopt: }
    error=${error%%"${LF}"*}
    case $error in
        *' -- '*) option=${error#* -- }
                  [ "$option" = - ] && option=${1#-}
                  option=${option#-}
                  error=${error% -- *}
                  error="$error -- ${YELLOW}$option${NORMAL}" ;;
        *'`'*\'*) option=${error#*\`};
                  option=${option%\'*};
                  error="${error%%\`*}'${YELLOW}$option${NORMAL}'${error##*\'}" ;;
        *\'*\'*)  option=${error#*\'};
                  option=${option%\'*};
                  error="${error%%\'*}'${YELLOW}$option${NORMAL}'${error##*\'}" ;;
    esac

    echo >&2 "${BOLD}${RED}error:${NORMAL} $error"
}

err() {
    colors NORMAL

    if [ "$2" = 0 ]; then
        printf >&2 '%s\n' "${NORMAL}$1"; return
    fi

    colors BOLD RED YELLOW

    escape=$(printf '\033')
    case $1 in
        '')       echo   >&2 '' ;;
        $escape*) printf >&2 '%s\n' "$1" ;;

        $jq:\ *\<unknown\>*parsing*)
                 error=${1#"$jq": }
                 error=${error#error*: }
                 echo >&2 "${BOLD}${RED}error:${NORMAL} ${YELLOW}SRCENV_RESTORE${NORMAL} environment variable contains ${RED}invalid JSON${NORMAL}: $error" ;;

        $jq:\ *) LF='
'
                 error=${1#"$jq": }
                 error=${error#error: }
                 error=${error%%, line 1:"${LF}"*}
                 echo >&2 "${BOLD}${RED}error:${NORMAL} ${BOLD}Invalid format:${NORMAL} $error" ;;

        *) printf '%s\n' "$1" | while IFS= read -r line; do
               line=${line#"$0": }
               line=${line#line [0-9]*: }
               line=${line#"$0"\[[0-9]*\]: }

               echo >&2 "${BOLD}${RED}error:${NORMAL} $line"
           done ;;
    esac
}

colors() {
    for color in "$@"; do
        case $color in
            NORMAL)    NORMAL=${NORMAL:-$(      tput sgr0    2> /dev/null || printf '\033[0m')}  ;;
            BOLD)      BOLD=${BOLD:-$(          tput bold    2> /dev/null || printf '\033[1m')}  ;;
            DIM)       DIM=${DIM:-$(            tput dim     2> /dev/null || printf '\033[2m')}  ;;
            ITALIC)    ITALIC=${ITALIC:-$(      tput sitm    2> /dev/null || printf '\033[3m')}  ;;
            UNDERLINE) UNDERLINE=${UNDERLINE:-$(tput smul    2> /dev/null || printf '\033[4m')}  ;;
            BLACK)     BLACK=${BLACK:-$(        tput setaf 0 2> /dev/null || printf '\033[30m')} ;;
            RED)       RED=${RED:-$(            tput setaf 1 2> /dev/null || printf '\033[31m')} ;;
            GREEN)     GREEN=${GREEN:-$(        tput setaf 2 2> /dev/null || printf '\033[32m')} ;;
            YELLOW)    YELLOW=${YELLOW:-$(      tput setaf 3 2> /dev/null || printf '\033[33m')} ;;
            BLUE)      BLUE=${BLUE:-$(          tput setaf 4 2> /dev/null || printf '\033[34m')} ;;
            MAGENTA)   MAGENTA=${MAGENTA:-$(    tput setaf 5 2> /dev/null || printf '\033[35m')} ;;
            CYAN)      CYAN=${CYAN:-$(          tput setaf 6 2> /dev/null || printf '\033[36m')} ;;
            WHITE)     WHITE=${WHITE:-$(        tput setaf 7 2> /dev/null || printf '\033[37m')} ;;
        esac
    done
}

# endregion Help / Usage

# region init() / rc()

namecheck() {
    case $2 in
        *[!A-Za-z0-9_]*) invalid "$1" 'name must contain only alphanumeric and underscore characters -- -'; usage; help; exit 2 ;;
        [!A-Za-z]*)      invalid "$1" 'name must start with a letter -- -'; usage; help; exit 2 ;;
    esac
}

init() {
    name=src
    opts='--backup --restore --verbose'

    while [ $# -gt 0 ]; do
        case $1 in
            --cmd)   name=$(parse "$1" "$2" namecheck)             || exit $?; [ $# -gt 1 ] && shift; shift ;;
            --cmd=*) name=$(parse "${1%%=*}" "${1#*=}" namecheck)  || exit $?;                        shift ;;
            --)      shift; opts="$*";                                break ;;
            *)       invalid "$1" 'invalid option -- -'; usage; help; exit 2 ;;
        esac
    done

    case $0 in
        /*)  srcenv="$0" ;;
        ./*) srcenv="$PWD/${0#./}" ;;
        */*) srcenv="$PWD/$0" ;;
        *)   srcenv="$(command -v "$0")" || \
             srcenv="$PWD/$0" ;;
    esac

    case $shell in
        ash|dash|\
        bash|\
        ksh|pdksh|mksh|\
        posix|sh|\
        zsh)             echo "$name() { eval \"\$('$srcenv' $shell $opts --cmd $name \"\$@\")\"; }" ;;
        csh|tcsh)        if [ -e /dev/stdin ]; then
                             echo "alias $name '\"$srcenv\" $shell $opts --cmd $name \!* | source /dev/stdin'"
                         else
                             echo "alias $name 'set mktemp = \"\`mktemp\`\"; \"$srcenv\" $shell $opts --cmd $name \!* > \"\$mktemp\"; source \"\$mktemp\"; rm -f \"\$mktemp\"'"
                         fi ;;
        elvish)          echo "var $name = {|@a| eval ('$srcenv' $shell $opts --cmd $name \$@a | slurp) }" ;;
        fish)            echo "function $name; '$srcenv' $shell $opts --cmd $name \$argv | source; end" ;;
        murex)           echo "function $name { '$srcenv' $shell $opts --cmd $name @PARAMS -> source }" ;;
        nu|nushell)      echo "def --env --wrapped $name [...args] { ^'$srcenv' json $opts --cmd $name ...(\$args) | from json | default {} | load-env }" ;;
        pwsh|powershell) echo "function $name { \$script=((sh '$srcenv' $shell $opts --cmd $name \$args) -join \"\`n\"); if (\$script) { Invoke-Expression \$script } }" ;;
        cmd|command)     echo "DOSKEY $name=@echo off \$T sh '$srcenv' $shell $opts --cmd $name \$* \$G %TEMP%\srcenv.$name.cmd \$T\$T call %TEMP%\srcenv.$name.cmd \$T del %TEMP%\srcenv.$name.cmd \$T echo on" ;;
        env|\
        json|\
        launchctl)       nosupport init; return 1 ;;
    esac
}

rc() {
    name=; opts=

    while [ $# -gt 0 ]; do
        case $1 in
            --cmd)   name=$(parse "$1" "$2" namecheck)             || exit $?; [ $# -gt 1 ] && shift; shift ;;
            --cmd=*) name=$(parse "${1%%=*}" "${1#*=}" namecheck)  || exit $?;                        shift ;;
            --)      shift; opts="$*";                                break ;;
            *)       invalid "$1" 'invalid option -- -'; usage; help; exit 2 ;;
        esac
    done

    case $shell in
        csh|tcsh) quote='"' ;;
        *)        quote="'" ;;
    esac

    case $0 in
        /*)   srcenv="${quote}$0${quote}" ;;
        ./*)  srcenv="${quote}$PWD/${0#./}${quote}" ;;
        */*)  srcenv="${quote}$PWD/$0${quote}" ;;
        *\ *) srcenv="${quote}$0${quote}" ;;
        *)    command -v "$0" > /dev/null && srcenv=$0 || \
              srcenv="${quote}$0${quote}" ;;
    esac

    case $shell in
        ash|posix|sh)    echo "eval \"\$($srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"})\"" ;;
        bash|dash|\
        ksh|pdksh|mksh|\
        zsh)             echo "source <($srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"})" ;;
        csh|tcsh)        if [ -e /dev/stdin ]; then
                             echo "$srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"} | source /dev/stdin"
                         else
                             echo "eval \"\`$srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"})\`\""
                         fi ;;
        elvish)          echo "var ${name:-src}~ = { }; eval &on-end={|ns| set ${name:-src}~ = \$ns[${name:-src}] } ($srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"})" ;;
        fish)            echo "$srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"} | source" ;;
        murex)           echo "$srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"} -> source }" ;;
        nu|nushell)      echo '# Add to env.nu'
                         echo "^$srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"} | save -f ${name:-srcenv}.init.nu"
                         echo
                         echo '# Add to config.nu'
                         echo "source ${name:-srcenv}.init.nu" ;;
        pwsh|powershell) echo "Invoke-Expression (sh $srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"})" ;;
        cmd|command)     echo 'rem Initialize:'
                         echo "@echo off & sh $srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"} > %TEMP%\srcenv.init.cmd && call %TEMP%\srcenv.init.cmd & del %TEMP%\srcenv.init.cmd & echo on"
                         echo
                         echo 'rem AutoRun:'
                         echo "reg add \"HKCU\\SOFTWARE\\Microsoft\\Command Processor\" /v AutoRun /t REG_SZ /d \"@echo off & sh $srcenv init $shell${name:+" --cmd $name"}${opts:+" -- $opts"} > %TEMP%\srcenv.init.cmd && call %TEMP%\srcenv.init.cmd & del %TEMP%\srcenv.init.cmd & echo on\"" ;;
        env|\
        json|\
        launchctl)       nosupport rc; return 1 ;;
    esac
}

# endregion init() / rc()

# region setformat()

fmt() { format='if .[$k] != null then "'$1'" else "'$2'" end'; }

setformat() {
    case $1 in
        ash|dash|\
        bash|\
        ksh|pdksh|mksh|\
        posix|sh|\
        zsh)             fmt 'export \($k)=\(.[$k]|@sh)' \
                             'unset \($k)' ;;
        csh|tcsh)        fmt 'setenv \($k) \(.[$k]|@sh|gsub("\\n"; "\\\n"))' \
                             'unsetenv \($k)' ;;
        elvish)          fmt 'set-env \($k) \(.[$k]|@sh|gsub("'"'\\\\\\\\''"'"; "'\'\''"))' \
                             'unset-env \($k)' ;;
        fish)            fmt 'set -gx \($k) \(.[$k]|@sh)' \
                             'set -e \($k)' ;;
        murex)           fmt 'out \(.[$k]|@sh) -> export \($k)' \
                             '!export \($k)' ;;
        nu|nushell)      fmt '$env.\($k) = r#'"'"'\(.[$k])'"'"'#' \
                             '$env.\($k) = null' ;;
        pwsh|powershell) fmt '$Env:\($k) = \(.[$k]|@sh|gsub("'"'\\\\\\\\''"'"; "'\'\''"))' \
                             '$Env:\($k) = $null' ;;
        env)             fmt '\($k)=\(.[$k]|@sh)' \
                             '\($k)=' ;;
        json)            format=. ;;
        cmd|command)     fmt 'set \($k)=\(.[$k] | gsub("\n"; "%\\n%"))' \
                             'set \($k)='
                         prefix='"@echo off\n\n(set \\n=^^^\n\n^\n\n)\n\n" + (['
                         suffix='] | join("\n")) + "\n\nset \\n="' ;;
        launchctl)       fmt 'launchctl setenv \($k) \(.[$k]|@sh)' \
                             'launchctl unsetenv \($k)' ;;
        *)               return 1 ;;
    esac
}

# endregion setformat()

# region run()

build() {
    [ -n "$exclude" ] && exclude="|del(${exclude%, })"
    [ -n "$modify"  ] && modify= || modify='$snapshot[$k] == null and '

    diff='reduce (env|del(.SHLVL, ._, ._AST_FEATURES)'$exclude'|keys_unsorted[]) as $k ({}; if '$modify'env[$k] != $snapshot[$k] then .[$k]=env[$k] else . end)'
    ffid='reduce (env|del(.SHLVL, ._, ._AST_FEATURES)'$exclude'|keys_unsorted[]) as $k ({}; if '$modify'env[$k] != $snapshot[$k] then .[$k]=$snapshot[$k] else . end)'

    if [ -z "$sort" ]; then
        keys='keys_unsorted[] as $k'
        sort=.
    else
        keys='keys[] as $k'
        sort='to_entries | sort_by(.key) | from_entries'
    fi

    [ "$format" = . ] && keys=$sort
    [ -n "$backup"  ] && backup='| ('$ffid') as $ffid | if $ffid != {} then . += { SRCENV_RESTORE: ($ffid | . += { SRCENV_RESTORE: null } | '$sort' | tostring) } else . end'
    [ -n "$restore" ] && restore='env.SRCENV_RESTORE // "{}" | fromjson | . += '
    [ -n "$clear"   ] && restore="$restore{ SRCENV_RESTORE: null } | . += "
    [ -n "$fixpath" ] && fixpath='| if .PATH then .PATH = (.PATH|gsub("\\\\"; "/")|gsub("(?<drive>.):/"; "/" + (.drive|ascii_downcase) + "/")|gsub(";"; ":")) end'

    if [ -n "$verbose" ]; then
        [ "$format" = . ] && format='keys[] as $k | "  \($k|tojson): \(.[$k]|tojson)"' && \
                             prefix='"{\n" + ([' && \
                             suffix='] | join(",\n")) + "\n}" | if . == "{\n\n}" then "{}" else . end'

        [ -z "$prefix" ] && prefix='(['
        [ -z "$suffix" ] && suffix='] | join("\n"))'

        colors NORMAL BOLD ITALIC DIM RED GREEN YELLOW

        header="${BOLD}${DIM}srcenv:${NORMAL} "
        changed="$restore $diff ${backup:+"| . += { SRCENV_RESTORE: \"\" }"}"
        added="\"${GREEN}+\\(\$k)${NORMAL}\""
        modified="\"${YELLOW}~\\(\$k)${NORMAL}\""
        removed="\"${RED}-\\(\$k)${NORMAL}\""
        nochanges="\"${ITALIC}No changes${NORMAL}\""
        verbose='+ "\n'$header'" + (['$changed' | keys[] as $k | if .[$k] then if $snapshot[$k] then '$modified' else '$added' end else '$removed' end] | join(", ") | if . == "" then '$nochanges' else . end)'
    fi
}

parse() {
    case $2 in
        -*|'') invalid "$1" 'option requires an argument -- -'; usage; help; return 2 ;;
        *)     [ -n "$3" ] && ! "$3" "$1 '$2'" "$2" && return $?; printf '%s' "$2" ;;
    esac
}

run() {
    src=src; arg=; input=; action=; prefix=; suffix=; exclude=; format=; backup=; restore=; clear=; modify=1; export=; sort=1; fixpath=; verbose=

    setformat "$shell"

    while [ $# -gt 0 ] && [ "$1" != -- ]; do
        arg=1
        case $1 in
            --cmd)   cmd=$(parse "$1" "$2") || exit $?; [ $# -gt 1 ] && shift; arg=; input=; action=; shift ;;
            --cmd=*) cmd=$(parse "${1%%=*}" "${1#*=}") || exit $?;             arg=; input=; action=; shift ;;

            -x|--exclude)     value=$(parse "$1" "$2" namecheck) || exit $?; [ $# -gt 1 ] && shift
                              exclude="$exclude.$value, "; shift ;;
            -x=*|--exclude=*) value=$(parse "${1%%=*}" "${1#*=}" namecheck) || exit $?
                              exclude="$exclude.$value, "; shift ;;

            -f|--format)     value=$(parse "$1" "$2") || exit $?; [ $# -gt 1 ] && shift
                             setformat "$value" || fmt "${value%\?\?*}" "${value#*\?\?}"; shift ;;
            -f=*|--format=*) value=$(parse "${1%%=*}" "${1#*=}") || exit $?
                             setformat "$value" || fmt "${value%\?\?*}" "${value#*\?\?}"; shift ;;

            -b|--backup)   backup=1; clear=;  input=1;  shift ;;
            -r|--restore)  restore=1;         action=1; shift ;;
            -c|--clear)    backup=; clear=1;  action=1; shift ;;
            -n)            backup=; restore=;           shift ;;
            --no-backup)   backup=;                     shift ;;
            --no-restore)  restore=;                    shift ;;
            -m|--modify)        modify=1;               shift ;;
            -w|--write-protect) modify=;                shift ;;
            -j|--json)     src=json;          input=1;  shift ;;
            -p|--posix)    src=src;           input=1;  shift ;;
            -e|--export)   export=--export;   input=1;  shift ;;
            -l|--local)    export=0;          input=1;  shift ;;
            -s|--sort)     sort=1;                      shift ;;
            -u|--unsorted) sort=;                       shift ;;
            -q|--quiet)    verbose=;                    shift ;;
            -v|--verbose)  verbose=1;                   shift ;;
            --usage)       header; usage; desc; help; man;          exit 0 ;;
            -\?|-h|--help) header; usage; desc; options; help; man; exit 0 ;;
            --version)     version;                                 exit 0 ;;

            -i|--input)     value=$(parse "$1" "$2") || exit $?; [ $# -gt 1 ] && shift
                            set -- "$@" -- --input "$value"; shift ;;
            -i=*|--input=*) value=$(parse "${1%%=*}" "${1#*=}") || exit $?
                            set -- "$@" -- --input "$value"; shift ;;
            -)              set -- "$@" -- -;                shift ;;

            -*) if opts=$(getopt 'bcef:hi:jlmnpqrsuvwx:' "$1" 2>&1) && shift; then
                    # shellcheck disable=SC2086
                    if [ -n "$ZSH_VERSION" ]; then
                        setopt shwordsplit > /dev/null 2>&1
                        set -- ${opts% --} "$@"
                        unsetopt shwordsplit > /dev/null 2>&1
                    else
                        set -- ${opts% --} "$@"
                    fi

                    continue
                else
                    invalid "$1" "$opts"; usage; help; exit 2
                fi ;;
            *)  set -- "$@" -- "$1"; shift ;;
        esac
    done

    if [ $# = 0 ]; then
        if [ -z "$arg" ]; then
            header; usage; desc; help; man; exit 0
        elif [ -n "$input" ] || [ -z "$action" ]; then
            noinput; usage; help; exit 2
        fi
    fi

    if [ -z "$format" ]; then
        noformat; usage; help; exit 2
    elif [ -n "$COMSPEC" ]; then
        case $shell in
            pwsh|powershell|cmd|command) ;;
            *) fixpath=1 ;;
        esac
    fi

    if ! jq=$(command -v "$jq"); then
        nojq; exit 1
    fi

    snapshot=$("$jq" -n env) || exit $?

    while [ $# -gt 0 ]; do
        case $1 in
            --)      shift ;;
            --input) "$src" var "$2"     "$export"             || exit $?; shift; shift ;;
            -)       "$src" var "$(cat)" "$export"             || exit $?; shift ;;
            *.env)   "$src" file "$1"    "${export:---export}" || exit $?; shift ;;
            *)       "$src" file "$1"    "$export"             || exit $?; shift ;;
        esac
    done

    build

    if [ -n "$verbose" ]; then
        # shellcheck disable=SC2086
        stdout=$("$jq" $SRCENV_JQ_OPTS --argjson snapshot "$snapshot" \
            -rn "$prefix $restore $diff $backup $fixpath | $keys | $format $suffix $verbose")
        exitcode=$?

        printf 1>&2 "%s\n" "${stdout##*"${LF}"}"
        printf      "%s\n" "${stdout%"${LF}"*}"

        exit "$exitcode"
    else
        # shellcheck disable=SC2086
        "$jq" $SRCENV_JQ_OPTS --argjson snapshot "$snapshot" \
            -rn "$prefix $restore $diff $backup $fixpath | $keys | $format $suffix"
    fi
}

src() {
    exitcode=0

    [ "$3" = --export ] && set -a

    # shellcheck disable=SC3044
    [ -n "$BASH_VERSION" ] && shopt -s expand_aliases 2> /dev/null
    alias exit=return

    if [ "$1" = var ]; then
        if [ -n "$ZSH_VERSION" ]; then
            eval "srcenv_zsh_input() { $2; }; srcenv_zsh_input" 1>&2 || exitcode=$?
        else
            eval "$2" 1>&2 || exitcode=$?
        fi
    elif [ -f "$2" ]; then
        # shellcheck disable=SC1090
        case $2 in
            .*|/*) .   "$2" 1>&2 || exitcode=$? ;;
            *)     . "./$2" 1>&2 || exitcode=$? ;;
        esac
    else
        echo >&2 "$2: No such file or directory"
        exitcode=2
    fi

    # shellcheck disable=SC3044
    [ -n "$BASH_VERSION" ] && shopt -u expand_aliases 2> /dev/null
    unalias exit

    [ "$3" = --export ] && set +a

    return "$exitcode"
}

json() {
    if [ "$1" = var ]; then
        # shellcheck disable=SC2086
        env=$(printf "%s\n" "$2" | "$jq" $SRCENV_JQ_OPTS -r 'keys[] as $k | "export \($k)=\(.[$k]|@sh)"') || return 5
    elif [ -f "$2" ]; then
        # shellcheck disable=SC2086
        env=$("$jq" $SRCENV_JQ_OPTS -r 'keys[] as $k | "export \($k)=\(.[$k]|@sh)"' "$2") || return 5
    else
        echo >&2 "$2: No such file or directory"
        return 2
    fi

    eval "$env" 1>&2 || return $?
}

# endregion run()

jq=${SRCENV_JQ:-jq}
cmd=

case $1 in
    init|rc) command=$1; shift ;;
    *)       command= ;;
esac

case $1 in
    ash|dash|\
    bash|\
    ksh|pdksh|mksh|\
    posix|sh|\
    zsh|\
    csh|tcsh|\
    elvish|\
    fish|\
    murex|\
    nu|nushell|\
    pwsh|powershell|\
    env|\
    json|\
    cmd|command|\
    launchctl) shell=$1; shift ;;
    *)         shell= ;;
esac

if [ "$command" = init ] || [ "$command" = rc ]; then
    if [ -z "$shell" ]; then
        noshell "$1"; usage; help; exit 2
    fi

    "$command" "$@"; exit $?
fi

[ ! -t 0 ] && set -- "$@" -
[ $# = 0 ] && set -- --usage

DLM=$(printf '\032')
LF='
'

capture() {
    # shellcheck disable=SC2153
    if [ "$KSH_VERSION" = "Version AJM 93u+ 2012-08-01" ]; then
        stdout=$( (printf "${DLM}%s${DLM}" "$(trap 'printf "${DLM}%d" "$?"' EXIT; "$@" 3>&1 1>&2 2>&3)" ) 2>&1 )
        exitcode=${stdout%"${DLM}"*"${DLM}"}
        exitcode=${exitcode#*"${DLM}"}
        stderr=${stdout%"${DLM}"}
        stderr=${stderr##*"${DLM}"}
        stderr=${stderr%"${LF}"}
        stdout=${stdout%%"${DLM}"*}
        stdout=${stdout%"${LF}"}
    else
        stdout=$( (printf "${DLM}%s${DLM}" "$(trap 'printf "${DLM}%d" "$?"' EXIT; "$@")" 1>&2) 2>&1 )
        exitcode=${stdout%"${DLM}"}
        exitcode=${exitcode##*"${DLM}"}
        stderr=${stdout%%"${DLM}"*}
        stderr=${stderr%"${LF}"}
        stdout=${stdout#*"${DLM}"}
        stdout=${stdout%"${DLM}"*"${DLM}"}
        stdout=${stdout%"${LF}"}
    fi

    return "$exitcode"
}

capture run "$@"

[ -n "$stderr" ] && err "$stderr" "$exitcode"
[ -n "$stdout" ] && printf '%s\n' "$stdout"

exit "$exitcode"
