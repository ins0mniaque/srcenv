#!/bin/sh
#
# srcenv - A cross-shell tool for sourcing POSIX compliant .env scripts
#
# shellcheck disable=SC2016
# shellcheck disable=SC2317

version() {
    if [ -z "$cmd" ]; then
        echo 'srcenv 1.5.15'
    else
        out 'srcenv 1.5.15'
    fi
}

# region Help / Usage

header() { out 'srcenv is a cross-shell tool for sourcing POSIX compliant .env scripts.'; }

desc() {
    out "
srcenv takes a snapshot of the POSIX shell environment, sources the .env scripts
and prints a shell specific script exporting the environment variables that have
changed since the snapshot."
}

help() {
    colors NORMAL BOLD

    out "
For listing the command options, use '${cmd:-${0##*/}} ${BOLD}--help${NORMAL}'."
}

man() {
    colors NORMAL ITALIC

    out "
For more advanced usage see the srcenv(1) manpage ${ITALIC}('man srcenv')${NORMAL} and/or
https://github.com/ins0mniaque/srcenv."
}

usage() {
    colors NORMAL BOLD ITALIC UNDERLINE YELLOW

    if [ -z "$cmd" ]; then
        warn=; command -v "$jq" > /dev/null || \
        warn=$(printf "%$((32 + (${#NORMAL} * 2 + ${#BOLD} * 2 + ${#YELLOW})))s" \
                      "${BOLD}${YELLOW}warning: ${NORMAL}${BOLD}$jq${NORMAL} not found")

        out "
${BOLD}${UNDERLINE}Usage${NORMAL}: ${BOLD}srcenv${NORMAL} <${ITALIC}shell${NORMAL}> [${ITALIC}options${NORMAL}] [${ITALIC}files${NORMAL}]         $warn
              init|rc <${ITALIC}shell${NORMAL}> [--cmd ${ITALIC}name${NORMAL}] [-- ${ITALIC}options${NORMAL}]
              [-h|--help|--version]"
    else
        warn=; command -v "$jq" > /dev/null || \
        warn=$(printf "%$((46 - ${#cmd} + (${#NORMAL} * 2 + ${#BOLD} * 2 + ${#YELLOW})))s" \
                      "${BOLD}${YELLOW}warning: ${NORMAL}${BOLD}$jq${NORMAL} not found")
        help=$(printf "%$((29 + ${#cmd}))s" \
                      "[-h|--help|--version]")

        out "
${BOLD}${UNDERLINE}Usage${NORMAL}: ${BOLD}$cmd${NORMAL} [${ITALIC}options${NORMAL}] [${ITALIC}files${NORMAL}]         $warn
$help"
    fi
}

options() {
    colors NORMAL BOLD ITALIC UNDERLINE

    if [ -z "$cmd" ]; then
        out "
${BOLD}${UNDERLINE}Commands${NORMAL}:
  ${BOLD}init              ${NORMAL}Generate the initialization script
  ${BOLD}rc                ${NORMAL}Generate the command to install the initialization script

${BOLD}${UNDERLINE}Shells${NORMAL}:
  ${BOLD}ash, dash         ${NORMAL}Format the output as an Ash/Dash script
  ${BOLD}bash              ${NORMAL}Format the output as a Bash script
  ${BOLD}cmd, command      ${NORMAL}Format the output as a Windows Command shell script
  ${BOLD}csh, tcsh         ${NORMAL}Format the output as a Csh/Tcsh script
  ${BOLD}elvish            ${NORMAL}Format the output as an Elvish script
  ${BOLD}env               ${NORMAL}Format the output as a .env file
  ${BOLD}fish              ${NORMAL}Format the output as a Fish script
  ${BOLD}json              ${NORMAL}Format the output as JSON
  ${BOLD}ksh, pdksh, mksh  ${NORMAL}Format the output as a Ksh script
  ${BOLD}launchctl         ${NORMAL}Format the output as a launchctl calls ${ITALIC}(macOS)${NORMAL}
  ${BOLD}murex             ${NORMAL}Format the output as a Murex script
  ${BOLD}nu, nushell       ${NORMAL}Format the output as a Nushell script
  ${BOLD}posix, sh         ${NORMAL}Format the output as a POSIX shell script
  ${BOLD}pwsh, powershell  ${NORMAL}Format the output as a PowerShell script
  ${BOLD}zsh               ${NORMAL}Format the output as a Zsh script"
    fi

    out "
${BOLD}${UNDERLINE}Options${NORMAL}:
  ${BOLD}--color WHEN, --color=WHEN  ${NORMAL}Specify when to use colored output: ${BOLD:-*}auto${BOLD:-*}${NORMAL}, never or always
                              ${ITALIC}${DIM}i.e. 'auto' disables colors if the output goes to a pipe${NORMAL}
  ${BOLD}-x VAR, --exclude VAR,
  ${BOLD}-x=VAR, --exclude=VAR       ${NORMAL}Exclude VAR from exported variables ${ITALIC}(can be used multiple times)${NORMAL}
  ${BOLD}-f FORMAT, --format FORMAT,
  ${BOLD}-f=FORMAT, --format=FORMAT  ${NORMAL}Format the output as anything ${ITALIC}(shell or jq interpolated string)${NORMAL}
                              ${ITALIC}${DIM}e.g. 'json' or '\(\$k)=\(.[\$k]|@sh)??\(\$k)='${NORMAL}
  ${BOLD}-i INPUT, --input INPUT,
  ${BOLD}-i=INPUT, --input=INPUT     ${NORMAL}Source from string value of INPUT
  ${BOLD}-                           ${NORMAL}Source from STDIN
  ${BOLD}-b, --backup                ${NORMAL}Backup changes to SRCENV_RESTORE for restore
  ${BOLD}-r, --restore               ${NORMAL}Restore backed up changes from SRCENV_RESTORE
  ${BOLD}-c, --clear                 ${NORMAL}Clear backed up changes from SRCENV_RESTORE
  ${BOLD}-n                          ${NORMAL}Do not backup changes and do not restore backed up changes
  ${BOLD}--no-backup                 ${NORMAL}Do not backup changes to SRCENV_RESTORE for restore
  ${BOLD}--no-restore                ${NORMAL}Do not restore backed up changes from SRCENV_RESTORE
  ${BOLD}-m, --modify                ${NORMAL}Allow modifying existing environment variables ${ITALIC}(Default)${NORMAL}
  ${BOLD}-w, --write-protect         ${NORMAL}Do not allow modifying existing environment variables
  ${BOLD}-j, --json                  ${NORMAL}Treat input as JSON${NORMAL}
  ${BOLD}-p, --posix                 ${NORMAL}Treat input as POSIX ${ITALIC}(Default)${NORMAL}
  ${BOLD}-e, --export                ${NORMAL}Export all variables ${ITALIC}(Default for .env files)${NORMAL}
  ${BOLD}-l, --local                 ${NORMAL}Do not export all variables
  ${BOLD}-s, --sort                  ${NORMAL}Sort the environment variables alphabetically ${ITALIC}(Default)${NORMAL}
  ${BOLD}-u, --unsorted              ${NORMAL}Keep the environment variables unsorted
  ${BOLD}-q, --quiet                 ${NORMAL}Do not display changed environment variables
  ${BOLD}-v, --verbose               ${NORMAL}Display changed environment variables
  ${BOLD}-d, --debug                 ${NORMAL}Display jq filter without sourcing and exit
  ${BOLD}-h, --help                  ${NORMAL}Display help and exit
  ${BOLD}--version                   ${NORMAL}Display the version number and exit"
}

noinput() {
    colors NORMAL BOLD RED

    out "${BOLD}${RED}error:${NORMAL} no input files or arguments"
}

nojq() {
    colors NORMAL BOLD RED GREEN YELLOW

    [ "$jq" != jq ] && \
    out "${BOLD}${YELLOW}warn: ${NORMAL} ${YELLOW}jq${NORMAL} is set to ${GREEN}$jq${NORMAL}; unset ${YELLOW}SRCENV_JQ${NORMAL} to revert to ${GREEN}jq${NORMAL}"
    out "${BOLD}${RED}error:${NORMAL} ${YELLOW}jq${NORMAL} not found; see https://jqlang.github.io/jq/download for installation options"
}

noformat() {
    colors NORMAL BOLD RED

    out "${BOLD}${RED}error:${NORMAL} no shell or format specified"
}

noshell() {
    colors NORMAL BOLD RED YELLOW

    case $1 in
        '') out "${BOLD}${RED}error:${NORMAL} no shell specified" ;;
        *)  out "${BOLD}${RED}error:${NORMAL} ${YELLOW}$1${NORMAL} is not a supported shell"
    esac
}

nosupport() {
    colors NORMAL BOLD RED YELLOW

    out "${BOLD}${RED}error:${NORMAL} ${BOLD}$1${NORMAL} not supported for shell ${YELLOW}$shell${NORMAL}"
}

invalid() {
    colors NORMAL BOLD RED YELLOW

    out "${BOLD}${RED}error:${NORMAL} ${2:-invalid option} -- ${YELLOW}$1${NORMAL}"
}

err() {
    if [ "$2" = 0 ]; then
        out "$1"; return
    fi

    colors NORMAL BOLD RED YELLOW

    escape=$(printf '\033')
    case $1 in
        '')       out '' ;;
        $escape*) out "$1" ;;

        $jq:\ *\<unknown\>*parsing*)
                 error=${1#"$jq": }
                 error=${error#error*: }
                 out "${BOLD}${RED}error:${NORMAL} ${YELLOW}SRCENV_RESTORE${NORMAL} environment variable contains ${RED}invalid JSON${NORMAL}: $error" ;;

        $jq:\ *) error=${1#"$jq": }
                 error=${error#error: }
                 error=${error%%, line 1:"${LF}"*}
                 out "${BOLD}${RED}error:${NORMAL} ${BOLD}Invalid format:${NORMAL} $error" ;;

        *) printf '%s\n' "$1" | while IFS= read -r line; do
               line=${line#"$0": }
               line=${line#line [0-9]*: }
               line=${line#"$0"\[[0-9]*\]: }

               out "${BOLD}${RED}error:${NORMAL} $line"
           done ;;
    esac
}

out() { echo >&2 "$1"; }

[ -n "$MUREX_PID" ] && out() {
    colors NORMAL

    printf '%s\n' "$1" | while IFS= read -r line; do
        echo >&2 "${NORMAL}$line"
    done
}

[ -t 1 ] && colorless= || colorless=1
color=${SRCENV_COLOR:-auto}
colors=$SRCENV_COLORS

NORMAL=; BOLD=; DIM=; ITALIC=; UNDERLINE=
BLACK=; RED=; GREEN=; YELLOW=; BLUE=; MAGENTA=; CYAN=; WHITE=

colors() {
    case $color in
        never)  return ;;
        always) ;;
        *)      [ -n "$colorless" ] && [ -z "$cmd" ] && return ;;
    esac

    if [ -n "$SRCENV_COLORS" ]; then
        [ -z "$colors" ] && return

        NORMAL=${colors%%"${DLM}"*};    colors=${colors#*"${DLM}"}
        BOLD=${colors%%"${DLM}"*};      colors=${colors#*"${DLM}"}
        DIM=${colors%%"${DLM}"*};       colors=${colors#*"${DLM}"}
        ITALIC=${colors%%"${DLM}"*};    colors=${colors#*"${DLM}"}
        UNDERLINE=${colors%%"${DLM}"*}; colors=${colors#*"${DLM}"}
        BLACK=${colors%%"${DLM}"*};     colors=${colors#*"${DLM}"}
        RED=${colors%%"${DLM}"*};       colors=${colors#*"${DLM}"}
        GREEN=${colors%%"${DLM}"*};     colors=${colors#*"${DLM}"}
        YELLOW=${colors%%"${DLM}"*};    colors=${colors#*"${DLM}"}
        BLUE=${colors%%"${DLM}"*};      colors=${colors#*"${DLM}"}
        MAGENTA=${colors%%"${DLM}"*};   colors=${colors#*"${DLM}"}
        CYAN=${colors%%"${DLM}"*};      colors=${colors#*"${DLM}"}
        WHITE=${colors%%"${DLM}"*};     colors=

        return
    fi

    for var in "$@"; do
        case $var in
            NORMAL)    NORMAL=${NORMAL:-$(      tput sgr0    2> /dev/null || printf '\033[0m')}  ;;
            BOLD)      BOLD=${BOLD:-$(          tput bold    2> /dev/null || printf '\033[1m')}  ;;
            DIM)       DIM=${DIM:-$(            tput dim     2> /dev/null || printf '\033[2m')}  ;;
            ITALIC)    ITALIC=${ITALIC:-$(      tput sitm    2> /dev/null || printf '\033[3m')}  ;;
            UNDERLINE) UNDERLINE=${UNDERLINE:-$(tput smul    2> /dev/null || printf '\033[4m')}  ;;
            BLACK)     BLACK=${BLACK:-$(        tput setaf 0 2> /dev/null || printf '\033[30m')} ;;
            RED)       RED=${RED:-$(            tput setaf 1 2> /dev/null || printf '\033[31m')} ;;
            GREEN)     GREEN=${GREEN:-$(        tput setaf 2 2> /dev/null || printf '\033[32m')} ;;
            YELLOW)    YELLOW=${YELLOW:-$(      tput setaf 3 2> /dev/null || printf '\033[33m')} ;;
            BLUE)      BLUE=${BLUE:-$(          tput setaf 4 2> /dev/null || printf '\033[34m')} ;;
            MAGENTA)   MAGENTA=${MAGENTA:-$(    tput setaf 5 2> /dev/null || printf '\033[35m')} ;;
            CYAN)      CYAN=${CYAN:-$(          tput setaf 6 2> /dev/null || printf '\033[36m')} ;;
            WHITE)     WHITE=${WHITE:-$(        tput setaf 7 2> /dev/null || printf '\033[37m')} ;;
        esac
    done
}

exportcolors() {
    color=always
    colors NORMAL BOLD DIM ITALIC UNDERLINE BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE
    export SRCENV_COLORS="$NORMAL${DLM}$BOLD${DLM}$DIM${DLM}$ITALIC${DLM}$UNDERLINE${DLM}$BLACK${DLM}$RED${DLM}$GREEN${DLM}$YELLOW${DLM}$BLUE${DLM}$MAGENTA${DLM}$CYAN${DLM}$WHITE"
}

clearcolors() {
    unset SRCENV_COLORS
}

validcolor() {
    case $2 in
        auto|always|never) ;;
        *) colors NORMAL GREEN
           invalid "$1" "color must be either ${GREEN}auto${NORMAL}, ${GREEN}never${NORMAL} or ${GREEN}always${NORMAL}"; usage; help; exit 2 ;;
    esac
}

parse() {
    case $2 in
        -*|'') invalid "$1" 'option requires an argument'; usage; help; return 2 ;;
        *)     [ -n "$3" ] && ! "$3" "$1 '$2'" "$2" && return $?; printf '%s' "$2" ;;
    esac
}

# endregion Help / Usage

# region init() / rc()

arg0=$0

initrc() {
    case $shell in
        csh|tcsh) quote=\" ;;
        *)        quote=\' ;;
    esac

    case $arg0 in
        /*)  srcenv="${quote}$arg0${quote}" ;;
        ./*) srcenv="${quote}$PWD/${arg0#./}${quote}" ;;
        */*) srcenv="${quote}$PWD/$arg0${quote}" ;;
        *)   srcenv="${quote}$(command -v "$arg0")${quote}" || \
             srcenv="${quote}$PWD/$arg0${quote}" ;;
    esac

    while [ $# -gt 0 ]; do
        case $1 in
            --cmd)     name=$(parse "$1" "$2" validname)            || exit $?; [ $# -gt 1 ] && shift; shift ;;
            --cmd=*)   name=$(parse "${1%%=*}" "${1#*=}" validname) || exit $?;                        shift ;;
            --sh)      sh=$(parse "$1" "$2" validsh)                || exit $?; [ $# -gt 1 ] && shift; shift ;;
            --sh=*)    sh=$(parse "${1%%=*}" "${1#*=}" validsh)     || exit $?;                        shift ;;
            -h|--help) header; usage; desc; options; man; exit 0 ;;
            --version) version;                           exit 0 ;;
            --)        shift; opts="$*";                  break ;;
            *)         invalid "$1"; usage; help;         exit 2 ;;
        esac
    done
}

init() {
    name=src; sh=; opts='--backup --restore --verbose'

    case $shell in
        pwsh|powershell|cmd|command) sh='sh' ;;
    esac

    initrc "$@" || exit $?

    case $shell in
        nu|nushell) srcenv="${sh:+"$sh "}$srcenv json $opts --cmd $name" ;;
        *)          srcenv="${sh:+"$sh "}$srcenv $shell $opts --cmd $name" ;;
    esac

    case $shell in
        ash|dash|\
        bash|\
        ksh|pdksh|mksh|\
        posix|sh|\
        zsh)             echo "$name() { eval \"\$($srcenv \"\$@\")\"; }" ;;
        csh|tcsh)        if [ -e /dev/stdin ]; then
                             echo "alias $name '$srcenv \!* | source /dev/stdin'"
                         else
                             echo "alias $name 'set mktemp = \"\`mktemp\`\"; $srcenv \!* > \"\$mktemp\"; source \"\$mktemp\"; rm -f \"\$mktemp\"'"
                         fi ;;
        elvish)          echo "var $name = {|@a| eval ($srcenv \$@a | slurp) }" ;;
        fish)            echo "function $name; $srcenv \$argv | source; end" ;;
        murex)           echo "function $name { $srcenv @PARAMS -> source }" ;;
        nu|nushell)      echo "def --env --wrapped $name [...args] { ^$srcenv ...(\$args) | from json | default {} | load-env }" ;;
        pwsh|powershell) echo "function $name { \$script=(($srcenv \$args) -join \"\`n\"); if (\$script) { Invoke-Expression \$script } }" ;;
        cmd|command)     echo "DOSKEY $name=@echo off \$T $srcenv \$* \$G %TEMP%\srcenv.$name.cmd \$T\$T call %TEMP%\srcenv.$name.cmd \$T del %TEMP%\srcenv.$name.cmd \$T echo on" ;;
        env|\
        json|\
        launchctl)       nosupport init; return 1 ;;
    esac
}

rc() {
    name=; sh=; opts=

    initrc "$@" || exit $?

    srcenv="$srcenv init $shell${name:+" --cmd $name"}${sh:+" --sh $sh"}${opts:+" -- $opts"}"

    case $shell in
        ash|posix|sh)    echo "eval \"\$($srcenv)\"" ;;
        bash|dash|\
        ksh|pdksh|mksh|\
        zsh)             echo "source <($srcenv)" ;;
        csh|tcsh)        if [ -e /dev/stdin ]; then
                             echo "$srcenv | source /dev/stdin"
                         else
                             echo "eval \"\`$srcenv\`\""
                         fi ;;
        elvish)          echo "var ${name:-src}~ = { }; eval &on-end={|ns| set ${name:-src}~ = \$ns[${name:-src}] } ($srcenv)" ;;
        fish)            echo "$srcenv | source" ;;
        murex)           echo "$srcenv -> source }" ;;
        nu|nushell)      echo '# Add to env.nu'
                         echo "^$srcenv | save -f ${name:-srcenv}.init.nu"
                         echo
                         echo '# Add to config.nu'
                         echo "source ${name:-srcenv}.init.nu" ;;
        pwsh|powershell) echo "Invoke-Expression (sh $srcenv)" ;;
        cmd|command)     echo 'rem Initialize:'
                         echo "@echo off & sh $srcenv > %TEMP%\srcenv.init.cmd && call %TEMP%\srcenv.init.cmd & del %TEMP%\srcenv.init.cmd & echo on"
                         echo
                         echo 'rem AutoRun:'
                         echo "reg add \"HKCU\\SOFTWARE\\Microsoft\\Command Processor\" /v AutoRun /t REG_SZ /d \"@echo off & sh $srcenv > %TEMP%\srcenv.init.cmd && call %TEMP%\srcenv.init.cmd & del %TEMP%\srcenv.init.cmd & echo on\"" ;;
        env|\
        json|\
        launchctl)       nosupport rc; return 1 ;;
    esac
}

validname() {
    case $2 in
        *[!A-Za-z0-9_]*) invalid "$1" 'name must contain only alphanumeric and underscore characters'; usage; help; exit 2 ;;
        [!A-Za-z]*)      invalid "$1" 'name must start with a letter'; usage; help; exit 2 ;;
    esac
}

validsh() {
    if ! command -v "$2" >/dev/null; then
        invalid "$1" 'POSIX shell not found'; usage; help; exit 2
    fi
}

# endregion init() / rc()

# region setformat()

fmt() { format='if .[$k] != null then "'$1'" else "'$2'" end'; }

setformat() {
    case $1 in
        ash|dash|\
        bash|\
        ksh|pdksh|mksh|\
        posix|sh|\
        zsh)             fmt 'export \($k)=\(.[$k]|@sh)' \
                             'unset \($k)' ;;
        csh|tcsh)        fmt 'setenv \($k) \(.[$k]|@sh|gsub("\\n"; "\\\n"))' \
                             'unsetenv \($k)' ;;
        elvish)          fmt 'set-env \($k) \(.[$k]|@sh|gsub("'"'\\\\\\\\''"'"; "'\'\''"))' \
                             'unset-env \($k)' ;;
        fish)            fmt 'set -gx \($k) \(.[$k]|@sh)' \
                             'set -e \($k)' ;;
        murex)           fmt 'out \(.[$k]|@sh) -> export \($k)' \
                             '!export \($k)' ;;
        nu|nushell)      fmt '$env.\($k) = \(.[$k]|@json)' \
                             '$env.\($k) = null' ;;
        pwsh|powershell) fmt '$Env:\($k) = \(.[$k]|@sh|gsub("'"'\\\\\\\\''"'"; "'\'\''"))' \
                             '$Env:\($k) = $null' ;;
        env)             fmt '\($k)=\(.[$k]|@sh)' \
                             '\($k)=' ;;
        json)            format=. ;;
        cmd|command)     fmt 'set \($k)=\(.[$k] | gsub("\n"; "%\\n%"))' \
                             'set \($k)='
                         prefix='"@echo off\n\n(set \\n=^^^\n\n^\n\n)\n\n" + (['
                         suffix='] | join("\n")) + "\n\nset \\n="' ;;
        launchctl)       fmt 'launchctl setenv \($k) \(.[$k]|@sh)' \
                             'launchctl unsetenv \($k)' ;;
        *)               return 1 ;;
    esac
}

# endregion setformat()

# region run()

build() {
    [ -n "$exclude" ] && exclude="|del(${exclude%, })"
    [ -n "$modify"  ] && modify= || modify='$snapshot[$k] == null and '

    diff='reduce ($snapshot|. += env|del(.PWD, .OLDPWD, .SHLVL, ._, ._AST_FEATURES)'$exclude'|keys_unsorted[]) as $k ({}; if '$modify'env[$k] != $snapshot[$k] then .[$k]=env[$k] else . end)'
    ffid='reduce ($snapshot|. += env|del(.PWD, .OLDPWD, .SHLVL, ._, ._AST_FEATURES)'$exclude'|keys_unsorted[]) as $k ({}; if '$modify'env[$k] != $snapshot[$k] then .[$k]=$snapshot[$k] else . end)'

    if [ -z "$sort" ]; then
        keys='keys_unsorted[] as $k'
        sort=.
    else
        keys='keys[] as $k'
        sort='to_entries | sort_by(.key) | from_entries'
    fi

    [ "$format" = . ] && keys=$sort
    [ -n "$backup"  ] && backup='| ('$ffid') as $ffid | if $ffid != {} then . += { SRCENV_RESTORE: ($ffid | . += { SRCENV_RESTORE: null } | '$sort' | tostring) } else . end'
    [ -n "$restore" ] && restore='env.SRCENV_RESTORE // "{}" | fromjson | . += '
    [ -n "$clear"   ] && restore="$restore{ SRCENV_RESTORE: null } | . += "
    [ -n "$fixpath" ] && fixpath='| if .PATH then .PATH = (.PATH|gsub("\\\\"; "/")|gsub("(?<drive>.):/"; "/" + (.drive|ascii_downcase) + "/")|gsub(";"; ":")) end'

    if [ -n "$verbose" ]; then
        [ "$format" = . ] && format='keys[] as $k | "  \($k|tojson): \(.[$k]|tojson)"' && \
                             prefix='"{\n" + ([' && \
                             suffix='] | join(",\n")) + "\n}" | if . == "{\n\n}" then "{}" else . end'

        [ -z "$prefix" ] && prefix='(['
        [ -z "$suffix" ] && suffix='] | join("\n"))'

        colors NORMAL BOLD ITALIC DIM RED GREEN YELLOW

        header="${BOLD}${DIM}srcenv:${NORMAL} "
        changed="$restore $diff ${backup:+"| . += { SRCENV_RESTORE: \"\" }"}"
        added="\"${GREEN}+\\(\$k)${NORMAL}\""
        modified="\"${YELLOW}~\\(\$k)${NORMAL}\""
        removed="\"${RED}-\\(\$k)${NORMAL}\""
        nochanges="\"${ITALIC}No changes${NORMAL}\""
        verbose='+ "\n'$header'" + (['$changed' | keys[] as $k | if .[$k] then if $snapshot[$k] then '$modified' else '$added' end else '$removed' end] | join(", ") | if . == "" then '$nochanges' else . end)'
    fi

    filter=". as \$snapshot | $prefix $restore $diff $backup $fixpath | $keys | $format $suffix $verbose"
}

DLM=$(printf '\032')
LF='
'

capture() {
    # shellcheck disable=SC2153
    if [ "$KSH_VERSION" = "Version AJM 93u+ 2012-08-01" ]; then
        stdout=$( (printf "${DLM}%s${DLM}" "$(trap 'printf "${DLM}%d" "$?"' EXIT; "$@" 3>&1 1>&2 2>&3)" ) 2>&1 )
        exitcode=${stdout%"${DLM}"*"${DLM}"}
        exitcode=${exitcode#*"${DLM}"}
        stderr=${stdout%"${DLM}"}
        stderr=${stderr##*"${DLM}"}
        stderr=${stderr%"${LF}"}
        stdout=${stdout%%"${DLM}"*}
        stdout=${stdout%"${LF}"}
    else
        stdout=$( (printf "${DLM}%s${DLM}" "$(trap 'printf "${DLM}%d" "$?"' EXIT; "$@")" 1>&2) 2>&1 )
        exitcode=${stdout%"${DLM}"}
        exitcode=${exitcode##*"${DLM}"}
        stderr=${stdout%%"${DLM}"*}
        stderr=${stderr%"${LF}"}
        stdout=${stdout#*"${DLM}"}
        stdout=${stdout%"${DLM}"*"${DLM}"}
        stdout=${stdout%"${LF}"}
    fi

    return "$exitcode"
}

run() {
    if ! jq=$(command -v "$jq"); then
        nojq; exit 1
    fi

    pwd=$PWD
    snapshot=$("$jq" -n env) || exit $?

    [ -n "$colorize" ] && "$colorize"

    while [ $# -gt 0 ]; do
        case $1 in
            --)      shift ;;
            --input) "$src" var "$2"     "$export"             || exit $?; shift; shift ;;
            -)       stdin=; while read -r line; do stdin="$stdin$line${LF}"; done
                     stdin=${stdin%"${LF}"}
                     "$src" var "$stdin" "$export"             || exit $?; shift ;;
            *.env)   "$src" file "$1"    "${export:---export}" || exit $?; shift ;;
            *)       "$src" file "$1"    "$export"             || exit $?; shift ;;
        esac
    done

    if [ -n "$verbose" ]; then
        stdout=$(printf "%s\n" "$snapshot" | "$jq" ${SRCENV_JQ_BINARY:+-b} -r "$filter")
        exitcode=$?

        out           "${stdout##*"${LF}"}"
        printf "%s\n" "${stdout%"${LF}"*}"

        exit "$exitcode"
    else
        printf "%s\n" "$snapshot" | "$jq" ${SRCENV_JQ_BINARY:+-b} -r "$filter"
    fi
}

src() {
    exitcode=0

    [ "$3" = --export ] && set -a

    # shellcheck disable=SC3044
    [ -n "$BASH_VERSION" ] && shopt -s expand_aliases 2> /dev/null
    alias exit=return

    if [ "$1" = var ]; then
        if [ -n "$ZSH_VERSION" ]; then
            eval "srcenv_zsh_input() { $2; }; srcenv_zsh_input" 1>&2 || exitcode=$?
        else
            eval "$2" 1>&2 || exitcode=$?
        fi
    elif [ -f "$2" ]; then
        # shellcheck disable=SC1090
        case $2 in
            */*) cd "${2%/*}" && \
                 . "./${2##*/}" 1>&2 || exitcode=$? ;;
            *)   . "./$2"       1>&2 || exitcode=$? ;;
        esac

        cd "$pwd" || exitcode=$?
    else
        out "$2: No such file or directory"
        exitcode=2
    fi

    # shellcheck disable=SC3044
    [ -n "$BASH_VERSION" ] && shopt -u expand_aliases 2> /dev/null
    unalias exit

    [ "$3" = --export ] && set +a

    return "$exitcode"
}

json() {
    if [ "$1" = var ]; then
        env=$(printf "%s\n" "$2" | "$jq" ${SRCENV_JQ_BINARY:+-b} -r 'keys[] as $k | "export \($k)=\(.[$k]|@sh)"') || return 5
    elif [ -f "$2" ]; then
        env=$("$jq" ${SRCENV_JQ_BINARY:+-b} -r 'keys[] as $k | "export \($k)=\(.[$k]|@sh)"' "$2") || return 5
    else
        out "$2: No such file or directory"
        return 2
    fi

    eval "$env" 1>&2 || return $?
}

# endregion run()

jq=${SRCENV_JQ:-jq}
cmd=

case $1 in
    init|rc) command=$1; shift ;;
    *)       command= ;;
esac

case $1 in
    ash|dash|\
    bash|\
    ksh|pdksh|mksh|\
    posix|sh|\
    zsh|\
    csh|tcsh|\
    elvish|\
    fish|\
    murex|\
    nu|nushell|\
    pwsh|powershell|\
    env|\
    json|\
    cmd|command|\
    launchctl) shell=$1; shift ;;
    *)         shell= ;;
esac

if [ "$command" = init ] || [ "$command" = rc ]; then
    if [ -z "$shell" ]; then
        noshell "$1"; usage; help; exit 2
    fi

    "$command" "$@"; exit $?
fi

[ ! -t 0 ] && set -- "$@" -

src=src; arg=; input=; action=; colorize=; debug=
prefix=; suffix=; exclude=; format=; backup=; restore=; clear=
modify=1; export=; sort=1; fixpath=; verbose=

setformat "$shell"

while [ $# -gt 0 ] && [ "$1" != -- ]; do
    arg=1
    case $1 in
        --cmd)   cmd=$(parse "$1" "$2") || exit $?; [ $# -gt 1 ] && shift; arg=; input=; action=; shift ;;
        --cmd=*) cmd=$(parse "${1%%=*}" "${1#*=}") || exit $?;             arg=; input=; action=; shift ;;

        --color)         color=$(parse "$1" "$2" validcolor) || exit $?; [ $# -gt 1 ] && shift; shift ;;
        --color=*)       color=$(parse "${1%%=*}" "${1#*=}" validcolor) || exit $?;             shift ;;
        --export-colors) colorize=exportcolors;                                       action=1; shift ;;
        --clear-colors)  colorize=clearcolors;                                        action=1; shift ;;

        -x|--exclude)     value=$(parse "$1" "$2" validname) || exit $?; [ $# -gt 1 ] && shift
                          exclude="$exclude.$value, "; shift ;;
        -x=*|--exclude=*) value=$(parse "${1%%=*}" "${1#*=}" validname) || exit $?
                          exclude="$exclude.$value, "; shift ;;

        -f|--format)     value=$(parse "$1" "$2") || exit $?; [ $# -gt 1 ] && shift
                         setformat "$value" || fmt "${value%\?\?*}" "${value#*\?\?}"; shift ;;
        -f=*|--format=*) value=$(parse "${1%%=*}" "${1#*=}") || exit $?
                         setformat "$value" || fmt "${value%\?\?*}" "${value#*\?\?}"; shift ;;

        -b|--backup)   backup=1; clear=;  input=1;  shift ;;
        -r|--restore)  restore=1;         action=1; shift ;;
        -c|--clear)    backup=; clear=1;  action=1; shift ;;
        -n)            backup=; restore=;           shift ;;
        --no-backup)   backup=;                     shift ;;
        --no-restore)  restore=;                    shift ;;
        -m|--modify)        modify=1;               shift ;;
        -w|--write-protect) modify=;                shift ;;
        -j|--json)     src=json;          input=1;  shift ;;
        -p|--posix)    src=src;           input=1;  shift ;;
        -e|--export)   export=--export;   input=1;  shift ;;
        -l|--local)    export=0;          input=1;  shift ;;
        -s|--sort)     sort=1;                      shift ;;
        -u|--unsorted) sort=;                       shift ;;
        -q|--quiet)    verbose=;                    shift ;;
        -v|--verbose)  verbose=1;                   shift ;;
        -d|--debug)    debug=1;                     shift ;;
        -h|--help)     header; usage; desc; options; man; exit 0 ;;
        --version)     version;                           exit 0 ;;

        -i|--input)     value=$(parse "$1" "$2") || exit $?; [ $# -gt 1 ] && shift
                        set -- "$@" -- --input "$value"; shift ;;
        -i=*|--input=*) value=$(parse "${1%%=*}" "${1#*=}") || exit $?
                        set -- "$@" -- --input "$value"; shift ;;
        -)              set -- "$@" -- -;                shift ;;

        -[!-]?*) opts=${1#??}; opt=${1%"$opts"}; shift
                 case $opt in -[!fix]) opts="-$opts" ;; esac
                 set -- "$opt" "$opts" "$@" ;;
        -*)      invalid "$1"; usage; help; exit 2 ;;
        *)       set -- "$@" -- "$1"; shift ;;
    esac
done

if [ $# = 0 ]; then
    if [ -z "$arg" ]; then
        header; usage; desc; help; man; exit 0
    elif [ -n "$input" ] || [ -z "$action" ]; then
        noinput; usage; help; exit 2
    elif [ -n "$colorize" ]; then
        backup=; restore=
    fi
fi

if [ -z "$format" ]; then
    noformat; usage; help; exit 2
elif [ -n "$COMSPEC" ]; then
    case $shell in
        pwsh|powershell|cmd|command) ;;
        *) fixpath=1 ;;
    esac
fi

build

if [ -n "$debug" ]; then
    command -v bat > /dev/null && filter=$(printf '%s\n' "$filter" | bat --color=always -pl jq)
    out "$filter"; exit 0
fi

capture run "$@"

[ -n "$stderr" ] && err "$stderr" "$exitcode"
[ -n "$stdout" ] && printf '%s\n' "$stdout"

exit "$exitcode"
